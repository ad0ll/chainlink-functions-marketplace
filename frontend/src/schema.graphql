# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type FunctionCallCompleted {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    callbackFunction: Bytes!
    caller: Bytes!
    err: Bytes!
    functionId: Bytes!
    id: Bytes!
    owner: Bytes!
    requestId: Bytes!
    response: Bytes!
    transactionHash: Bytes!
}

type FunctionCalled {
    baseFee: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    callbackFunction: Bytes!
    caller: Bytes!
    fee: BigInt!
    functionId: Bytes!
    id: Bytes!
    owner: Bytes!
    requestId: Bytes!
    transactionHash: Bytes!
}

type FunctionRegistered {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    functionId: Bytes!
    id: Bytes!
    metadata_desc: String!
    metadata_fee: BigInt!
    metadata_imageUrl: String!
    metadata_lockedProfitPool: BigInt!
    metadata_name: String!
    metadata_owner: Bytes!
    metadata_subId: BigInt!
    metadata_subscriptionPool: BigInt!
    metadata_unlockedProfitPool: BigInt!
    owner: Bytes!
    transactionHash: Bytes!
}

type OwnershipTransferred {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newOwner: Bytes!
    previousOwner: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    functionCallCompleted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCallCompleted
    functionCallCompleteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCallCompleted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCallCompleted_filter
    ): [FunctionCallCompleted!]!
    functionCalled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCalled
    functionCalleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCalled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCalled_filter
    ): [FunctionCalled!]!
    functionRegistered(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionRegistered
    functionRegistereds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionRegistered_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionRegistered_filter
    ): [FunctionRegistered!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    functionCallCompleted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCallCompleted
    functionCallCompleteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCallCompleted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCallCompleted_filter
    ): [FunctionCallCompleted!]!
    functionCalled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCalled
    functionCalleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCalled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCalled_filter
    ): [FunctionCalled!]!
    functionRegistered(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionRegistered
    functionRegistereds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionRegistered_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionRegistered_filter
    ): [FunctionRegistered!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum FunctionCallCompleted_orderBy {
    blockNumber
    blockTimestamp
    callbackFunction
    caller
    err
    functionId
    id
    owner
    requestId
    response
    transactionHash
}

enum FunctionCalled_orderBy {
    baseFee
    blockNumber
    blockTimestamp
    callbackFunction
    caller
    fee
    functionId
    id
    owner
    requestId
    transactionHash
}

enum FunctionRegistered_orderBy {
    blockNumber
    blockTimestamp
    functionId
    id
    metadata_desc
    metadata_fee
    metadata_imageUrl
    metadata_lockedProfitPool
    metadata_name
    metadata_owner
    metadata_subId
    metadata_subscriptionPool
    metadata_unlockedProfitPool
    owner
    transactionHash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum OwnershipTransferred_orderBy {
    blockNumber
    blockTimestamp
    id
    newOwner
    previousOwner
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input FunctionCallCompleted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionCallCompleted_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    callbackFunction: Bytes
    callbackFunction_contains: Bytes
    callbackFunction_gt: Bytes
    callbackFunction_gte: Bytes
    callbackFunction_in: [Bytes!]
    callbackFunction_lt: Bytes
    callbackFunction_lte: Bytes
    callbackFunction_not: Bytes
    callbackFunction_not_contains: Bytes
    callbackFunction_not_in: [Bytes!]
    caller: Bytes
    caller_contains: Bytes
    caller_gt: Bytes
    caller_gte: Bytes
    caller_in: [Bytes!]
    caller_lt: Bytes
    caller_lte: Bytes
    caller_not: Bytes
    caller_not_contains: Bytes
    caller_not_in: [Bytes!]
    err: Bytes
    err_contains: Bytes
    err_gt: Bytes
    err_gte: Bytes
    err_in: [Bytes!]
    err_lt: Bytes
    err_lte: Bytes
    err_not: Bytes
    err_not_contains: Bytes
    err_not_in: [Bytes!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [FunctionCallCompleted_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    requestId: Bytes
    requestId_contains: Bytes
    requestId_gt: Bytes
    requestId_gte: Bytes
    requestId_in: [Bytes!]
    requestId_lt: Bytes
    requestId_lte: Bytes
    requestId_not: Bytes
    requestId_not_contains: Bytes
    requestId_not_in: [Bytes!]
    response: Bytes
    response_contains: Bytes
    response_gt: Bytes
    response_gte: Bytes
    response_in: [Bytes!]
    response_lt: Bytes
    response_lte: Bytes
    response_not: Bytes
    response_not_contains: Bytes
    response_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FunctionCalled_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionCalled_filter]
    baseFee: BigInt
    baseFee_gt: BigInt
    baseFee_gte: BigInt
    baseFee_in: [BigInt!]
    baseFee_lt: BigInt
    baseFee_lte: BigInt
    baseFee_not: BigInt
    baseFee_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    callbackFunction: Bytes
    callbackFunction_contains: Bytes
    callbackFunction_gt: Bytes
    callbackFunction_gte: Bytes
    callbackFunction_in: [Bytes!]
    callbackFunction_lt: Bytes
    callbackFunction_lte: Bytes
    callbackFunction_not: Bytes
    callbackFunction_not_contains: Bytes
    callbackFunction_not_in: [Bytes!]
    caller: Bytes
    caller_contains: Bytes
    caller_gt: Bytes
    caller_gte: Bytes
    caller_in: [Bytes!]
    caller_lt: Bytes
    caller_lte: Bytes
    caller_not: Bytes
    caller_not_contains: Bytes
    caller_not_in: [Bytes!]
    fee: BigInt
    fee_gt: BigInt
    fee_gte: BigInt
    fee_in: [BigInt!]
    fee_lt: BigInt
    fee_lte: BigInt
    fee_not: BigInt
    fee_not_in: [BigInt!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [FunctionCalled_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    requestId: Bytes
    requestId_contains: Bytes
    requestId_gt: Bytes
    requestId_gte: Bytes
    requestId_in: [Bytes!]
    requestId_lt: Bytes
    requestId_lte: Bytes
    requestId_not: Bytes
    requestId_not_contains: Bytes
    requestId_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FunctionRegistered_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionRegistered_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    metadata_desc: String
    metadata_desc_contains: String
    metadata_desc_contains_nocase: String
    metadata_desc_ends_with: String
    metadata_desc_ends_with_nocase: String
    metadata_desc_gt: String
    metadata_desc_gte: String
    metadata_desc_in: [String!]
    metadata_desc_lt: String
    metadata_desc_lte: String
    metadata_desc_not: String
    metadata_desc_not_contains: String
    metadata_desc_not_contains_nocase: String
    metadata_desc_not_ends_with: String
    metadata_desc_not_ends_with_nocase: String
    metadata_desc_not_in: [String!]
    metadata_desc_not_starts_with: String
    metadata_desc_not_starts_with_nocase: String
    metadata_desc_starts_with: String
    metadata_desc_starts_with_nocase: String
    metadata_fee: BigInt
    metadata_fee_gt: BigInt
    metadata_fee_gte: BigInt
    metadata_fee_in: [BigInt!]
    metadata_fee_lt: BigInt
    metadata_fee_lte: BigInt
    metadata_fee_not: BigInt
    metadata_fee_not_in: [BigInt!]
    metadata_imageUrl: String
    metadata_imageUrl_contains: String
    metadata_imageUrl_contains_nocase: String
    metadata_imageUrl_ends_with: String
    metadata_imageUrl_ends_with_nocase: String
    metadata_imageUrl_gt: String
    metadata_imageUrl_gte: String
    metadata_imageUrl_in: [String!]
    metadata_imageUrl_lt: String
    metadata_imageUrl_lte: String
    metadata_imageUrl_not: String
    metadata_imageUrl_not_contains: String
    metadata_imageUrl_not_contains_nocase: String
    metadata_imageUrl_not_ends_with: String
    metadata_imageUrl_not_ends_with_nocase: String
    metadata_imageUrl_not_in: [String!]
    metadata_imageUrl_not_starts_with: String
    metadata_imageUrl_not_starts_with_nocase: String
    metadata_imageUrl_starts_with: String
    metadata_imageUrl_starts_with_nocase: String
    metadata_lockedProfitPool: BigInt
    metadata_lockedProfitPool_gt: BigInt
    metadata_lockedProfitPool_gte: BigInt
    metadata_lockedProfitPool_in: [BigInt!]
    metadata_lockedProfitPool_lt: BigInt
    metadata_lockedProfitPool_lte: BigInt
    metadata_lockedProfitPool_not: BigInt
    metadata_lockedProfitPool_not_in: [BigInt!]
    metadata_name: String
    metadata_name_contains: String
    metadata_name_contains_nocase: String
    metadata_name_ends_with: String
    metadata_name_ends_with_nocase: String
    metadata_name_gt: String
    metadata_name_gte: String
    metadata_name_in: [String!]
    metadata_name_lt: String
    metadata_name_lte: String
    metadata_name_not: String
    metadata_name_not_contains: String
    metadata_name_not_contains_nocase: String
    metadata_name_not_ends_with: String
    metadata_name_not_ends_with_nocase: String
    metadata_name_not_in: [String!]
    metadata_name_not_starts_with: String
    metadata_name_not_starts_with_nocase: String
    metadata_name_starts_with: String
    metadata_name_starts_with_nocase: String
    metadata_owner: Bytes
    metadata_owner_contains: Bytes
    metadata_owner_gt: Bytes
    metadata_owner_gte: Bytes
    metadata_owner_in: [Bytes!]
    metadata_owner_lt: Bytes
    metadata_owner_lte: Bytes
    metadata_owner_not: Bytes
    metadata_owner_not_contains: Bytes
    metadata_owner_not_in: [Bytes!]
    metadata_subId: BigInt
    metadata_subId_gt: BigInt
    metadata_subId_gte: BigInt
    metadata_subId_in: [BigInt!]
    metadata_subId_lt: BigInt
    metadata_subId_lte: BigInt
    metadata_subId_not: BigInt
    metadata_subId_not_in: [BigInt!]
    metadata_subscriptionPool: BigInt
    metadata_subscriptionPool_gt: BigInt
    metadata_subscriptionPool_gte: BigInt
    metadata_subscriptionPool_in: [BigInt!]
    metadata_subscriptionPool_lt: BigInt
    metadata_subscriptionPool_lte: BigInt
    metadata_subscriptionPool_not: BigInt
    metadata_subscriptionPool_not_in: [BigInt!]
    metadata_unlockedProfitPool: BigInt
    metadata_unlockedProfitPool_gt: BigInt
    metadata_unlockedProfitPool_gte: BigInt
    metadata_unlockedProfitPool_in: [BigInt!]
    metadata_unlockedProfitPool_lt: BigInt
    metadata_unlockedProfitPool_lte: BigInt
    metadata_unlockedProfitPool_not: BigInt
    metadata_unlockedProfitPool_not_in: [BigInt!]
    or: [FunctionRegistered_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OwnershipTransferred_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OwnershipTransferred_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newOwner: Bytes
    newOwner_contains: Bytes
    newOwner_gt: Bytes
    newOwner_gte: Bytes
    newOwner_in: [Bytes!]
    newOwner_lt: Bytes
    newOwner_lte: Bytes
    newOwner_not: Bytes
    newOwner_not_contains: Bytes
    newOwner_not_in: [Bytes!]
    or: [OwnershipTransferred_filter]
    previousOwner: Bytes
    previousOwner_contains: Bytes
    previousOwner_gt: Bytes
    previousOwner_gte: Bytes
    previousOwner_in: [Bytes!]
    previousOwner_lt: Bytes
    previousOwner_lte: Bytes
    previousOwner_not: Bytes
    previousOwner_not_contains: Bytes
    previousOwner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}
