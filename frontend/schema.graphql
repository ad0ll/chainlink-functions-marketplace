# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type FeeManagerCutUpdated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newFeeManagerCut: BigInt!
    transactionHash: Bytes!
}

type FulfillRequest {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    err: Bytes!
    id: Bytes!
    requestId: Bytes!
    response: Bytes!
    transactionHash: Bytes!
}

type FunctionCallCompleted {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    callbackFunction: Bytes!
    caller: Bytes!
    err: Bytes!
    functionId: Bytes!
    id: Bytes!
    owner: Bytes!
    requestId: Bytes!
    response: Bytes!
    transactionHash: Bytes!
}

type FunctionCalled {
    baseFee: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    callbackFunction: Bytes!
    caller: Bytes!
    fee: BigInt!
    functionId: Bytes!
    id: Bytes!
    owner: Bytes!
    requestId: Bytes!
    transactionHash: Bytes!
}

type FunctionRegistered {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Bytes!
    fee: BigInt!
    functionId: Bytes!
    id: Bytes!
    metadata_category: Bytes!
    metadata_desc: String!
    metadata_expectedArgs: [String!]!
    metadata_expectedReturnType: Int!
    metadata_imageUrl: String!
    metadata_name: String!
    metadata_owner: Bytes!
    owner: Bytes!
    subId: BigInt!
    transactionHash: Bytes!
}

type MaxGasLimitUpdated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newMaxGasLimit: BigInt!
    transactionHash: Bytes!
}

type MinimumSubscriptionBalanceUpdated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newMinimumSubscriptionBalance: BigInt!
    transactionHash: Bytes!
}

type OwnershipTransferRequested {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    from: Bytes!
    id: Bytes!
    to: Bytes!
    transactionHash: Bytes!
}

type OwnershipTransferred {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    from: Bytes!
    id: Bytes!
    to: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    feeManagerCutUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FeeManagerCutUpdated
    feeManagerCutUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FeeManagerCutUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FeeManagerCutUpdated_filter
    ): [FeeManagerCutUpdated!]!
    fulfillRequest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FulfillRequest
    fulfillRequests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FulfillRequest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FulfillRequest_filter
    ): [FulfillRequest!]!
    functionCallCompleted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCallCompleted
    functionCallCompleteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCallCompleted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCallCompleted_filter
    ): [FunctionCallCompleted!]!
    functionCalled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCalled
    functionCalleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCalled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCalled_filter
    ): [FunctionCalled!]!
    functionRegistered(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionRegistered
    functionRegistereds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionRegistered_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionRegistered_filter
    ): [FunctionRegistered!]!
    maxGasLimitUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MaxGasLimitUpdated
    maxGasLimitUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MaxGasLimitUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MaxGasLimitUpdated_filter
    ): [MaxGasLimitUpdated!]!
    minimumSubscriptionBalanceUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MinimumSubscriptionBalanceUpdated
    minimumSubscriptionBalanceUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MinimumSubscriptionBalanceUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MinimumSubscriptionBalanceUpdated_filter
    ): [MinimumSubscriptionBalanceUpdated!]!
    ownershipTransferRequested(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferRequested
    ownershipTransferRequesteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferRequested_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferRequested_filter
    ): [OwnershipTransferRequested!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
    requestFulfilled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RequestFulfilled
    requestFulfilleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RequestFulfilled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RequestFulfilled_filter
    ): [RequestFulfilled!]!
    requestSent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RequestSent
    requestSents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RequestSent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RequestSent_filter
    ): [RequestSent!]!
}

type RequestFulfilled {
    FunctionsManager_id: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
}

type RequestSent {
    FunctionsManager_id: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    feeManagerCutUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FeeManagerCutUpdated
    feeManagerCutUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FeeManagerCutUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FeeManagerCutUpdated_filter
    ): [FeeManagerCutUpdated!]!
    fulfillRequest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FulfillRequest
    fulfillRequests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FulfillRequest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FulfillRequest_filter
    ): [FulfillRequest!]!
    functionCallCompleted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCallCompleted
    functionCallCompleteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCallCompleted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCallCompleted_filter
    ): [FunctionCallCompleted!]!
    functionCalled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionCalled
    functionCalleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionCalled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionCalled_filter
    ): [FunctionCalled!]!
    functionRegistered(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FunctionRegistered
    functionRegistereds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FunctionRegistered_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FunctionRegistered_filter
    ): [FunctionRegistered!]!
    maxGasLimitUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MaxGasLimitUpdated
    maxGasLimitUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MaxGasLimitUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MaxGasLimitUpdated_filter
    ): [MaxGasLimitUpdated!]!
    minimumSubscriptionBalanceUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MinimumSubscriptionBalanceUpdated
    minimumSubscriptionBalanceUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MinimumSubscriptionBalanceUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MinimumSubscriptionBalanceUpdated_filter
    ): [MinimumSubscriptionBalanceUpdated!]!
    ownershipTransferRequested(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferRequested
    ownershipTransferRequesteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferRequested_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferRequested_filter
    ): [OwnershipTransferRequested!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
    requestFulfilled(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RequestFulfilled
    requestFulfilleds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RequestFulfilled_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RequestFulfilled_filter
    ): [RequestFulfilled!]!
    requestSent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RequestSent
    requestSents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RequestSent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RequestSent_filter
    ): [RequestSent!]!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum FeeManagerCutUpdated_orderBy {
    blockNumber
    blockTimestamp
    id
    newFeeManagerCut
    transactionHash
}

enum FulfillRequest_orderBy {
    blockNumber
    blockTimestamp
    err
    id
    requestId
    response
    transactionHash
}

enum FunctionCallCompleted_orderBy {
    blockNumber
    blockTimestamp
    callbackFunction
    caller
    err
    functionId
    id
    owner
    requestId
    response
    transactionHash
}

enum FunctionCalled_orderBy {
    baseFee
    blockNumber
    blockTimestamp
    callbackFunction
    caller
    fee
    functionId
    id
    owner
    requestId
    transactionHash
}

enum FunctionRegistered_orderBy {
    blockNumber
    blockTimestamp
    category
    fee
    functionId
    id
    metadata_category
    metadata_desc
    metadata_expectedArgs
    metadata_expectedReturnType
    metadata_imageUrl
    metadata_name
    metadata_owner
    owner
    subId
    transactionHash
}

enum MaxGasLimitUpdated_orderBy {
    blockNumber
    blockTimestamp
    id
    newMaxGasLimit
    transactionHash
}

enum MinimumSubscriptionBalanceUpdated_orderBy {
    blockNumber
    blockTimestamp
    id
    newMinimumSubscriptionBalance
    transactionHash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum OwnershipTransferRequested_orderBy {
    blockNumber
    blockTimestamp
    from
    id
    to
    transactionHash
}

enum OwnershipTransferred_orderBy {
    blockNumber
    blockTimestamp
    from
    id
    to
    transactionHash
}

enum RequestFulfilled_orderBy {
    FunctionsManager_id
    blockNumber
    blockTimestamp
    id
    transactionHash
}

enum RequestSent_orderBy {
    FunctionsManager_id
    blockNumber
    blockTimestamp
    id
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input FeeManagerCutUpdated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FeeManagerCutUpdated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newFeeManagerCut: BigInt
    newFeeManagerCut_gt: BigInt
    newFeeManagerCut_gte: BigInt
    newFeeManagerCut_in: [BigInt!]
    newFeeManagerCut_lt: BigInt
    newFeeManagerCut_lte: BigInt
    newFeeManagerCut_not: BigInt
    newFeeManagerCut_not_in: [BigInt!]
    or: [FeeManagerCutUpdated_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FulfillRequest_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FulfillRequest_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    err: Bytes
    err_contains: Bytes
    err_gt: Bytes
    err_gte: Bytes
    err_in: [Bytes!]
    err_lt: Bytes
    err_lte: Bytes
    err_not: Bytes
    err_not_contains: Bytes
    err_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [FulfillRequest_filter]
    requestId: Bytes
    requestId_contains: Bytes
    requestId_gt: Bytes
    requestId_gte: Bytes
    requestId_in: [Bytes!]
    requestId_lt: Bytes
    requestId_lte: Bytes
    requestId_not: Bytes
    requestId_not_contains: Bytes
    requestId_not_in: [Bytes!]
    response: Bytes
    response_contains: Bytes
    response_gt: Bytes
    response_gte: Bytes
    response_in: [Bytes!]
    response_lt: Bytes
    response_lte: Bytes
    response_not: Bytes
    response_not_contains: Bytes
    response_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FunctionCallCompleted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionCallCompleted_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    callbackFunction: Bytes
    callbackFunction_contains: Bytes
    callbackFunction_gt: Bytes
    callbackFunction_gte: Bytes
    callbackFunction_in: [Bytes!]
    callbackFunction_lt: Bytes
    callbackFunction_lte: Bytes
    callbackFunction_not: Bytes
    callbackFunction_not_contains: Bytes
    callbackFunction_not_in: [Bytes!]
    caller: Bytes
    caller_contains: Bytes
    caller_gt: Bytes
    caller_gte: Bytes
    caller_in: [Bytes!]
    caller_lt: Bytes
    caller_lte: Bytes
    caller_not: Bytes
    caller_not_contains: Bytes
    caller_not_in: [Bytes!]
    err: Bytes
    err_contains: Bytes
    err_gt: Bytes
    err_gte: Bytes
    err_in: [Bytes!]
    err_lt: Bytes
    err_lte: Bytes
    err_not: Bytes
    err_not_contains: Bytes
    err_not_in: [Bytes!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [FunctionCallCompleted_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    requestId: Bytes
    requestId_contains: Bytes
    requestId_gt: Bytes
    requestId_gte: Bytes
    requestId_in: [Bytes!]
    requestId_lt: Bytes
    requestId_lte: Bytes
    requestId_not: Bytes
    requestId_not_contains: Bytes
    requestId_not_in: [Bytes!]
    response: Bytes
    response_contains: Bytes
    response_gt: Bytes
    response_gte: Bytes
    response_in: [Bytes!]
    response_lt: Bytes
    response_lte: Bytes
    response_not: Bytes
    response_not_contains: Bytes
    response_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FunctionCalled_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionCalled_filter]
    baseFee: BigInt
    baseFee_gt: BigInt
    baseFee_gte: BigInt
    baseFee_in: [BigInt!]
    baseFee_lt: BigInt
    baseFee_lte: BigInt
    baseFee_not: BigInt
    baseFee_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    callbackFunction: Bytes
    callbackFunction_contains: Bytes
    callbackFunction_gt: Bytes
    callbackFunction_gte: Bytes
    callbackFunction_in: [Bytes!]
    callbackFunction_lt: Bytes
    callbackFunction_lte: Bytes
    callbackFunction_not: Bytes
    callbackFunction_not_contains: Bytes
    callbackFunction_not_in: [Bytes!]
    caller: Bytes
    caller_contains: Bytes
    caller_gt: Bytes
    caller_gte: Bytes
    caller_in: [Bytes!]
    caller_lt: Bytes
    caller_lte: Bytes
    caller_not: Bytes
    caller_not_contains: Bytes
    caller_not_in: [Bytes!]
    fee: BigInt
    fee_gt: BigInt
    fee_gte: BigInt
    fee_in: [BigInt!]
    fee_lt: BigInt
    fee_lte: BigInt
    fee_not: BigInt
    fee_not_in: [BigInt!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [FunctionCalled_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    requestId: Bytes
    requestId_contains: Bytes
    requestId_gt: Bytes
    requestId_gte: Bytes
    requestId_in: [Bytes!]
    requestId_lt: Bytes
    requestId_lte: Bytes
    requestId_not: Bytes
    requestId_not_contains: Bytes
    requestId_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FunctionRegistered_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FunctionRegistered_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: Bytes
    category_contains: Bytes
    category_gt: Bytes
    category_gte: Bytes
    category_in: [Bytes!]
    category_lt: Bytes
    category_lte: Bytes
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    fee: BigInt
    fee_gt: BigInt
    fee_gte: BigInt
    fee_in: [BigInt!]
    fee_lt: BigInt
    fee_lte: BigInt
    fee_not: BigInt
    fee_not_in: [BigInt!]
    functionId: Bytes
    functionId_contains: Bytes
    functionId_gt: Bytes
    functionId_gte: Bytes
    functionId_in: [Bytes!]
    functionId_lt: Bytes
    functionId_lte: Bytes
    functionId_not: Bytes
    functionId_not_contains: Bytes
    functionId_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    metadata_category: Bytes
    metadata_category_contains: Bytes
    metadata_category_gt: Bytes
    metadata_category_gte: Bytes
    metadata_category_in: [Bytes!]
    metadata_category_lt: Bytes
    metadata_category_lte: Bytes
    metadata_category_not: Bytes
    metadata_category_not_contains: Bytes
    metadata_category_not_in: [Bytes!]
    metadata_desc: String
    metadata_desc_contains: String
    metadata_desc_contains_nocase: String
    metadata_desc_ends_with: String
    metadata_desc_ends_with_nocase: String
    metadata_desc_gt: String
    metadata_desc_gte: String
    metadata_desc_in: [String!]
    metadata_desc_lt: String
    metadata_desc_lte: String
    metadata_desc_not: String
    metadata_desc_not_contains: String
    metadata_desc_not_contains_nocase: String
    metadata_desc_not_ends_with: String
    metadata_desc_not_ends_with_nocase: String
    metadata_desc_not_in: [String!]
    metadata_desc_not_starts_with: String
    metadata_desc_not_starts_with_nocase: String
    metadata_desc_starts_with: String
    metadata_desc_starts_with_nocase: String
    metadata_expectedArgs: [String!]
    metadata_expectedArgs_contains: [String!]
    metadata_expectedArgs_contains_nocase: [String!]
    metadata_expectedArgs_not: [String!]
    metadata_expectedArgs_not_contains: [String!]
    metadata_expectedArgs_not_contains_nocase: [String!]
    metadata_expectedReturnType: Int
    metadata_expectedReturnType_gt: Int
    metadata_expectedReturnType_gte: Int
    metadata_expectedReturnType_in: [Int!]
    metadata_expectedReturnType_lt: Int
    metadata_expectedReturnType_lte: Int
    metadata_expectedReturnType_not: Int
    metadata_expectedReturnType_not_in: [Int!]
    metadata_imageUrl: String
    metadata_imageUrl_contains: String
    metadata_imageUrl_contains_nocase: String
    metadata_imageUrl_ends_with: String
    metadata_imageUrl_ends_with_nocase: String
    metadata_imageUrl_gt: String
    metadata_imageUrl_gte: String
    metadata_imageUrl_in: [String!]
    metadata_imageUrl_lt: String
    metadata_imageUrl_lte: String
    metadata_imageUrl_not: String
    metadata_imageUrl_not_contains: String
    metadata_imageUrl_not_contains_nocase: String
    metadata_imageUrl_not_ends_with: String
    metadata_imageUrl_not_ends_with_nocase: String
    metadata_imageUrl_not_in: [String!]
    metadata_imageUrl_not_starts_with: String
    metadata_imageUrl_not_starts_with_nocase: String
    metadata_imageUrl_starts_with: String
    metadata_imageUrl_starts_with_nocase: String
    metadata_name: String
    metadata_name_contains: String
    metadata_name_contains_nocase: String
    metadata_name_ends_with: String
    metadata_name_ends_with_nocase: String
    metadata_name_gt: String
    metadata_name_gte: String
    metadata_name_in: [String!]
    metadata_name_lt: String
    metadata_name_lte: String
    metadata_name_not: String
    metadata_name_not_contains: String
    metadata_name_not_contains_nocase: String
    metadata_name_not_ends_with: String
    metadata_name_not_ends_with_nocase: String
    metadata_name_not_in: [String!]
    metadata_name_not_starts_with: String
    metadata_name_not_starts_with_nocase: String
    metadata_name_starts_with: String
    metadata_name_starts_with_nocase: String
    metadata_owner: Bytes
    metadata_owner_contains: Bytes
    metadata_owner_gt: Bytes
    metadata_owner_gte: Bytes
    metadata_owner_in: [Bytes!]
    metadata_owner_lt: Bytes
    metadata_owner_lte: Bytes
    metadata_owner_not: Bytes
    metadata_owner_not_contains: Bytes
    metadata_owner_not_in: [Bytes!]
    or: [FunctionRegistered_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    subId: BigInt
    subId_gt: BigInt
    subId_gte: BigInt
    subId_in: [BigInt!]
    subId_lt: BigInt
    subId_lte: BigInt
    subId_not: BigInt
    subId_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input MaxGasLimitUpdated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MaxGasLimitUpdated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newMaxGasLimit: BigInt
    newMaxGasLimit_gt: BigInt
    newMaxGasLimit_gte: BigInt
    newMaxGasLimit_in: [BigInt!]
    newMaxGasLimit_lt: BigInt
    newMaxGasLimit_lte: BigInt
    newMaxGasLimit_not: BigInt
    newMaxGasLimit_not_in: [BigInt!]
    or: [MaxGasLimitUpdated_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input MinimumSubscriptionBalanceUpdated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MinimumSubscriptionBalanceUpdated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newMinimumSubscriptionBalance: BigInt
    newMinimumSubscriptionBalance_gt: BigInt
    newMinimumSubscriptionBalance_gte: BigInt
    newMinimumSubscriptionBalance_in: [BigInt!]
    newMinimumSubscriptionBalance_lt: BigInt
    newMinimumSubscriptionBalance_lte: BigInt
    newMinimumSubscriptionBalance_not: BigInt
    newMinimumSubscriptionBalance_not_in: [BigInt!]
    or: [MinimumSubscriptionBalanceUpdated_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OwnershipTransferRequested_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OwnershipTransferRequested_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    from: Bytes
    from_contains: Bytes
    from_gt: Bytes
    from_gte: Bytes
    from_in: [Bytes!]
    from_lt: Bytes
    from_lte: Bytes
    from_not: Bytes
    from_not_contains: Bytes
    from_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [OwnershipTransferRequested_filter]
    to: Bytes
    to_contains: Bytes
    to_gt: Bytes
    to_gte: Bytes
    to_in: [Bytes!]
    to_lt: Bytes
    to_lte: Bytes
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OwnershipTransferred_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OwnershipTransferred_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    from: Bytes
    from_contains: Bytes
    from_gt: Bytes
    from_gte: Bytes
    from_in: [Bytes!]
    from_lt: Bytes
    from_lte: Bytes
    from_not: Bytes
    from_not_contains: Bytes
    from_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [OwnershipTransferred_filter]
    to: Bytes
    to_contains: Bytes
    to_gt: Bytes
    to_gte: Bytes
    to_in: [Bytes!]
    to_lt: Bytes
    to_lte: Bytes
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RequestFulfilled_filter {
    FunctionsManager_id: Bytes
    FunctionsManager_id_contains: Bytes
    FunctionsManager_id_gt: Bytes
    FunctionsManager_id_gte: Bytes
    FunctionsManager_id_in: [Bytes!]
    FunctionsManager_id_lt: Bytes
    FunctionsManager_id_lte: Bytes
    FunctionsManager_id_not: Bytes
    FunctionsManager_id_not_contains: Bytes
    FunctionsManager_id_not_in: [Bytes!]
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [RequestFulfilled_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [RequestFulfilled_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RequestSent_filter {
    FunctionsManager_id: Bytes
    FunctionsManager_id_contains: Bytes
    FunctionsManager_id_gt: Bytes
    FunctionsManager_id_gte: Bytes
    FunctionsManager_id_in: [Bytes!]
    FunctionsManager_id_lt: Bytes
    FunctionsManager_id_lte: Bytes
    FunctionsManager_id_not: Bytes
    FunctionsManager_id_not_contains: Bytes
    FunctionsManager_id_not_in: [Bytes!]
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [RequestSent_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [RequestSent_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}
